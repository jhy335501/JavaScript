# 자료형 심화

## 다양한 숫자 표기법

### 지수 표기법

알파벳 e의 왼쪽에 있는숫자에 오른쪽에 있는 수만큼 10의 거듭제곱을 곱함

ex. `2.37e-2` = 0.0237

## 숫자형 메소드

**toFixed 메소드 (범위 0 ~ 100)**

파라미터에 전달된 값만큼의 소수점 자릿수를 고정적으로 표기

- 파라미터에 전달된 값보다 소수점 자릿수가 더 많은 경우 → **바로 다음 자릿수에서 반올림**
- 파라미터에 전달된 값보다 소수점 자릿수가 더 적은 경우 → **남은 자리를 0으로 채움**

```jsx
let myNumber1 = 0.3591;
console.log(myNumber.toFixed(3)); // 0.359 출력
console.log(myNumber.toFixed(7)); // 0.3591000 출력. 7자리를 만들기 위해서 부족한 자릿수를 0으로 채운다.
```

**🚨 주의 :** **문자열로 리턴됨**

숫자를 원한다면 Number로 형변환 해야함

**참고)** **어떤 값 앞에 더하기 기호(+)**를 붙이면 **Number함수와 똑같은 결과**

ex. `+myNumber.toFixed(2)` ⇒ 숫자 0.35 리턴

**toString 메소드** (범위 2~36)

**파라미터로 전달하는 숫자의 진법으로 숫자를 변환**해주는 메소드 

2를 전달하면 2진수, 8을 전달하면 8진수로 변환

```jsx
let myNUmber = 255;

console.log(myNumber.toString(2)); // 11111111 출력
console.log(myNumber.toString(8));  // 377 출력
```

🚨 **주의 : 수를 변환한 다음 문자열로 리턴**

📌 변수에 수를 담고 변수 이름에 점 표기법으로 메소드를 사용하지 않고, **숫자에 바로 메소드 사용 가능**

- 정수 형태의 숫자 값에 바로 메소드를 사용할 때
    
    → 반드시 점 두개 사용 or 괄호로 감싸기 
    
    ex. `255..toString(2)`⇒ 111111111 리턴
    

## Math 객체

### Math 객체의 메소드

**절댓값**

Absolute number

**`Math.abs(x)`** → **x의 절댓값 리턴**

**최댓값**

Maximum

**`Math.max()`** 함수에 파라미터로 여러 수를 넘겨주면, 그 중 **가장 큰 값이 리턴**된다.

ex. `Math.max(2, -1, 4, 5, 0)` ⇒ 5 리턴

**최솟값 (Minimum)**

**`Math.min()`** 함수에 파라미터로 여러 수를 넘겨주면, 그중 **가장 작은 값이 리턴**됩니다.

ex. `Math.min(2, -1, 4, 5, 0)` ⇒ -1 리턴

**거듭제곱 (Exponentiation)**

**`Math.pow(x, y)`** : `x`의 `y`승의 결괏값이 리턴

ex. `Math.pow(2, 3)` ⇒ 8 리턴

**제곱근 (Square Root)**

**`Math.sqrt(x)`** : `x`의 제곱근이 리턴
ex. `Math.sqrt(25)` ⇒ 5 리턴

**반올림 (Round)**

**`Math.round(x)`** ⇒ `x`의 반올림된 값이 리턴

- 소수점 부분이 **`0.5` 이상**이면
    
    : 가장 가까운 정숫값으로 **올라감** 2.5, 2.7 →3
    
- 소수점 부분이 **`0.5` 미만**이면
    
    : 가장 가까운 정숫값으로 **내려감** 2.49, 2.3 → 2 
    

**버림과 올림 (Floor and Ceil)**

**`Math.floor(x)`** : `x`의 **버림 값** 리턴

나눗셈한 결과에 floor을 취하면 **몫**을 구할 수 있음
**`Math.ceil(x)`** : `x`의 **올림 값** 리턴

소수 부분이 얼마 인지와는 상관이 없음 

```jsx

//아래는 모두 2 출력
console.log(Math.floor(2.4));
console.log(Math.floor(2.49));
console.log(Math.floor(2.8));

//아래는 모두 3 출력
console.log(Math.ceil(2.4));
console.log(Math.ceil(2.49));
console.log(Math.ceil(2.8));

```

**난수 (Random)**

**`Math.random`** ⇒ **0 이상 1 미만**의 값이 랜덤으로 리턴됨

### 연산 오류

여러 프로그래밍 언어들은 소수 계산시 조금씩 연산 오류 발생

1. toFixed 함수 사용
2. Math.round 함수 사용
3. let x = 0.1;
let y = 0.2;

console.log(+(x + y).toFixed(1));
console.log(Math.round((x + y) * 10) / 10);

## 문자열 심화

문자열도 객체처럼 다룰 수 있다

배열과 비슷한 부분이 많음

### 문자열을 다루는 메소드

**문자열 길이**

```jsx
let myString = 'HiCodeit';
myString.length //  9
```

**요소 접근**

```jsx
// 대괄호 표기법
myString[3] // C

// charAt 메소드
myString.charAt[3] // C
```

**요소 탐색**

```jsx
// 앞부터 탐색
myString.indexOf('i'); // 1
myString.indexOf('a'); // -1 (문자열에 없는 문자를 찾는 경우)

// 뒤부터 탐색
myString.lastIndexOf('i'); // 7
```

**대소문자 변환**

```jsx
// 대문자로 변환
myString.toUpperCase(); // HI CODEIT

//소문자로 변환
myString.toLowerCase(); // hi codeit
```

**양끝 공백 제거**

```jsx
let myString = '  Hi Codeit  ';

// trim 메소드
myString.trim() // Hi Codeit
```

**부분 문자열 접근** 

`slice(start, end)` 

`(start)` 번 인덱스부터 `(end - 1)` 번 인덱스까지의 **부분 문자열을 가져온다**

- **두번째 파라미터를 생략** → **시작 지점부터 끝까지** 문자열을 리턴
- **모두 생략** → **문자열 전체**를 가져옴

```jsx
let myString = 'Hi Codeit';

myString.slice(0,2); // Hi
myString.slice(3) // Codeit
myString.slice() // Hi Codeit
```

## 문자열과 배열 사이

문자열과 배열

### 비슷한 점

- `length` 프로퍼티를 가짐
- **대괄호 표기법**으로 각 요소에 접근 가능
- `for..of`문 사용 가능

### 다른 점

- **자료형**
    - **문자열** : **string**
    - **배열** : **object**
- **수정 가능성**
    - **문자열** : **immutable** (바뀔 수 없는)
        - 한 번 할당된 값은 **수정불가**. 새로운 문자열을 지정해 주어야 함
        - 문자열이 가진 메소드들은 return값을 활용할 뿐, 본래의 문자열 값을 수정하지는 않음
        - splice 메소드 사용 불가
    - **배열** : **mutable** (바뀔 수 있는)
        - **할당 연산자를 통해 요소 수정 가능**

## 기본형과 참조형

### 기본형(Primitive Type)

기본형에 해당하는 자료형

: Number, Null, String, Undefined, Boolean

변수에 기본형 값을 할당 → 해당 변수 이름을 가진 상자에 **그 값을 넣어주는 것**

변수 = 값

**값이 그대로 할당된다**

```jsx
let x = 3;
let y = x; // x가 가지고 있는 값인 3을 그대로 복사해서 가짐

console.log(x); // 3 출력
console.log(y); // 3출력
y = 5; // y에 새로운 값 할당
console.log(x); // 3 출력
console.log(y); // 5 출력
```

### 참조형 (Reference Type)

참조형에 해당하는 자료형

: Object (배열 포함)

변수에 참조형 값을 할당 → 해당 값이 직접 저장되는 것이 아니라  **해당 객체를 가리키는 주소값이 저장됨**

변수 = 주소값

**주소값을 참조해서 그 값에 접근**

```jsx
let x = {name: 'Codeit'};
let y = x; // y에는 객체 값이 담긴 게 아니라 객체로 가는 주소가 복사된 것
// x와 y가 서로 같은 객체를 바라보게 됨

console.log(x);
console.log(y);
y.birth = 2017; // y에 새로운 프로퍼티 추가
console.log(x); // x에도 birth가 추가되어있음
//y만 수정했지만 x도 같이 수정이 된 것처럼 보임
console.log(y);  
```

객체나 배열이 할당된 변수를 다른 변수에 할당하면 서로 같은 객체를 가리키게 되고 결과적으로 한쪽을 수정하면 다른 한쪽도 같이 수정됨

```jsx
let x = {
	numbers: [1, 2, 3, 4],
	title: 'Codeit',
};
let y = x.numbers; // 배열의 주소값이 y에 할당됨
let z = x.titile;	// **값이 그대로 복사됨**
//x가 객체이지만 할당된 **title 프로퍼티의 값은 기본형**이기 때문
```

## 참조형 복사하기 (**Reference Type copy)**

### 배열 복사

: slice메소드 활용

```jsx
//numbers2의 값만 변경하고 싶을 때 
let numbers1 = [1, 2, 3];
let numbers2 = numbers1.slice();
//파라미터로 아무 값도 전달하지 않으면 원래 값이 그대로 리턴되는 특성을 활용 -> 배열을 복사
numbers2.push(4);

console.log(numbers1);
console.log(numbers2);
```

### 객체 : assign 메소드 활용 /  for…in문 활용

```jsx
let course1 = {
	title: '파이썬 프로그래밍 기초',
	alnguage: 'Python'
};

//방법 1 : assign 메소드 활용
let course2 = Object.assign({}, course1);

//방법 2 : for ... in 문 활용
let course2 = {};

for(let key in course1){
	course2[key] = course1[key];
}

course2.title = '알고리즘의 정석';

console.log(course1);
console.log(course2);
```

```jsx
function cloneObject(object){ // 파라미터로 복사할 객체를 전달받음
	let temp = {}; // 임시로 빈 객체를 만듦
	
	for (let key in object){
		temp[key] = object[key];
	} // for...in문을 통해 객체를 복사
	
	return temp; // 임시 객체를 리턴
};

let course2 = cloneObjext(course1);
let course3 = cloneObject(course1);

//course3,4가 생기거나 다른 객체를 복사해야할 떄도 효율적으로 사용 가능
```

🚨 **주의** : 객체/배열 안에 중첩해서 객체/배열이 있는 경우

→ 복사할 때 또 주소값이 복사됨

## 변수와 상수 사이

**변수를 const로 선언하는 이유**

- 날씨, 날짜, 사용자의 압력값 등에 따른 다양한 변수들이 존재하지만 **코드가 동작하는 순간에는 결국 상수로 쓰이는 경우**가 더 많음
    
    ex. 검색창에서 키워드를 입력받을 때 키워드는 변수임
    
    하지만 검색버튼을 눌러서 정보를 검색하는 동작을 수행할 때에는 키워드를 기준으로 필요한 정보를 찾아야하기 때문에 키워드의 값이 변해서는 안됨.
    
    → 검색 기능이 동작하는 순간에는 이 키워드가 상수라고 볼 수 있다
    
- 코드 속에 변하는 값이 많을수록 코드의 일관성을 유지하기가 어려움

**변수와 상수 구분**

**const 변수** 

- 변수 이름: camel case
    
    myName
    

**const 상수**

- 변수 이름: 대문자 + 밑줄
    
    MY_NAME
    

🚨 **주의** : const 키워드로 변수를 선언하면 값을 재할당할 수 없음 (Error 발생)

but, 할당된 값이 객체나 배열인 경우 메소드를 통해서 그 값을 변경할 수 있다

```jsx
// const로 선언했어도 splice 메소드 사용시 배열 수정 가능

let team1 = ['Drum', 'Bass', 'Saxophone'];
const team2 = team1;

team1.splice(2, 1, 'Trumpet');
team2.splice(2, 1, 'Piano');

console.log(team1); //[ 'Drum', 'Bass', 'Piano' ] 출력
console.log(team2); //[ 'Drum', 'Bass', 'Piano' ] 출력

```
